#!/usr/bin/perl

# check_tcptraffic is a nagios Nagios plugin to monitor the amount of TCP traffic
#
# check_tcptraffic uses the /proc/net/dev Linux entry to compute the
# amount of transferred bytes from the last plugin execution (temporary
# data is stored in the /tmp/check_tcptraffic-iface file)
#
# See  the INSTALL file for installation instructions
#
# Copyright (c) 2007, ETH Zurich.
#
# This module is free software; you can redistribute it and/or modify it
# under the terms of GNU general public license (gpl) version 3.
# See the LICENSE file for details.
#
# RCS information
# enable substitution with:
#   $ svn propset svn:keywords "Id Revision HeadURL Source Date"
#
#   $Id$
#   $Revision$
#   $HeadURL$
#   $Date$

use strict;
use warnings;
use 5.008;

use English qw(-no_match_vars);
use Getopt::Long;
use Nagios::Plugin::Threshold;
use Nagios::Plugin;

use version; our $VERSION = '2.0.3';

# IMPORTANT: Nagios plugins could be executed using embedded perl in this case
#            the main routine would be executed as a subroutine and all the
#            declared subroutines would therefore be inner subroutines
#            This will cause all the global lexical variables not to stay shared
#            in the subroutines!
#
# All variables are therefore declared as package variables...
#
use vars qw(
  $critical
  $help
  $interface
  $plugin
  $reset
  $result
  $threshold
  $speed
  $status
  $status_msg
  $tmp
  $verbosity
  $warning
);

##############################################################################
# subroutines

use subs qw(verbose);


##############################################################################
# Usage     : usage( -message => 'some text', -exitval => 1 )
# Purpose   : prints a usage message
# Returns   : n/a
# Arguments : -message : an optional error message
#             -exitval : the exit code (defaults to 0)
# Throws    : n/a
# Comments  : n/a
# See also  : n/a
sub usage {

    my %args = @_;

    my $exitval = 0;
    if ($args{-exitval}) {
        $exitval = $args{-exitval};
    }
    
    if ($args{-message}) {
        print $args{-message};
    }

    print<<'EOT';
check_tcptraffic --critical=crit --warning=warn --interface=iface --speed=speed
                 [--verbose] [--reset] [--help]

Required arguments
 --critical,c  crit      critical
 --warning,w   warn      warning
 --interface,i iface     network interface
 --speed,s               speed (in Mbit/s)

Options
 --help,-h,-?            this help message
 --reset,r               initialize counter
 --version,V             print version and exit
 --verbose,v             verbose
EOT

    exit $exitval;
    
}

##############################################################################
# Usage     : whoami()
# Purpose   : retrieve the user runnging the process
# Returns   : username
# Arguments : n/a
# Throws    : n/a
# Comments  : n/a
# See also  : n/a
sub whoami {

    my $output;

    my $pid = open $output, q{-|}, 'whoami'
      or
      $plugin->nagios_exit( UNKNOWN, "Cannot determine the user: $OS_ERROR" );

    while (<$output>) {
        chomp;
        return $_;
    }

    $plugin->nagios_exit( UNKNOWN, 'Cannot determine the user' );

    return;
}

##############################################################################
# Usage     : write_timer($data_in, $data_out)
# Purpose   : writes the time and transmit data to the temporary file
# Returns   : n/a
# Arguments : n/a
# Throws    : n/a
# Comments  : n/a
# See also  : n/a
sub write_timer {

    my $in  = shift;
    my $out = shift;

    my $TMP;    # file handler

    open $TMP, q{>}, $tmp
      or $plugin->nagios_exit( UNKNOWN, "Cannot initialize timer: $OS_ERROR" );

    print {$TMP} time . " $in $out\n";

    close $TMP
      or $plugin->nagios_exit( UNKNOWN, "Cannot close timer: $OS_ERROR" );

    return;

}

##############################################################################
# Usage     : read_proc('eth0')
# Purpose   : reads information about an interface in the proc file system
# Returns   : an hash containing the interface info
# Arguments : iface : interface name
# Throws    : n/a
# Comments  : n/a
# See also  : n/a
sub read_proc {

    my $iface = shift;

    my %data;

    my $found = 0;
    my $in;
    my $out;
    my $time;

    my $IN;     # file descriptor
    my $TMP;    # file descriptor

    my $dev_file = '/proc/net/dev';

    open $IN, q{<}, $dev_file
      or $plugin->nagios_exit( UNKNOWN, "Cannot open $dev_file: $OS_ERROR" );

    while (<$IN>) {
        
        chomp;

        if (/:/mx) {

            # /proc/net/dev format
            #
            # bytes:      The total number of bytes of data transmitted or received
            #             by the interface.
            # packets:    The total number of packets of data transmitted or
            #             received by the interface.
            # errs:       The total number of transmit or receive errors detected
            #             by the device driver.
            # drop:       The total number of packets dropped by the device driver.
            # fifo        The number of FIFO buffer errors.
            # frame:      The number of packet framing errors.
            # compressed: The number of compressed packets transmitted or received
            #             by the device driver.
            # multicast:  The number of multicast frames transmitted or received by
            #             the device driver.

            # hack: some kernels now put some whitespace between the colon and bytes in
            s/:\s+/:/mx;
            
            my (
                $combined,      $packets_in,   $errs_in,
                $drop_in,       $fifo_in,      $frame_in,
                $compressed_in, $multicast_in, $bytes_out,
                $packets_out,   $errs_out,     $drop_out,
                $fifo_out,      $frame_out,    $compressed_out,
                $multicast_out
            ) = split;
            
            my ( $name, $bytes_in ) = split /:/mx, $combined;

            if ( $name eq $interface ) {
                
                $found = 1;

                $data{combined}       = $combined;
                $data{packets_in}     = $packets_in;
                $data{errs_in}        = $errs_in;
                $data{drop_in}        = $drop_in;
                $data{fifo_in}        = $fifo_in;
                $data{frame_in}       = $frame_in;
                $data{compressed_in}  = $compressed_in;
                $data{multicast_in}   = $multicast_in;
                $data{bytes_out}      = $bytes_out;
                $data{packets_out}    = $packets_out;
                $data{errs_out}       = $errs_out;
                $data{drop_out}       = $drop_out;
                $data{fifo_out}       = $fifo_out;
                $data{frame_out}      = $frame_out;
                $data{compressed_out} = $compressed_out;
                $data{multicast_out}  = $multicast_out;
                $data{bytes_in}       = $bytes_in;

                # get the time difference
                if ( $reset || !open $TMP, q{<}, $tmp ) {
                    write_timer( $bytes_in, $bytes_out );
                    $plugin->nagios_exit( UNKNOWN, 'Initializing timer' );
                }

                while (<$TMP>) {
                    chomp;
                    ( $time, $in, $out ) = split;
                    $data{diff} = time - $time;
                    $data{in}   = $in;
                    $data{out}  = $out;
                }

                close $TMP
                  or $plugin->nagios_exit( UNKNOWN,
                    "Cannot close $tmp: $OS_ERROR" );

                write_timer( $bytes_in, $bytes_out );

                last;

            }

        }

    }

    if ( !$found ) {
        $plugin->nagios_exit( UNKNOWN, "Interface $interface not found" );
    }

    close $IN
      or $plugin->nagios_exit( UNKNOWN, "Cannot close $dev_file: $OS_ERROR" );

    return %data;

}

##############################################################################
# Usage     : verbose("some message string", $optional_verbosity_level);
# Purpose   : write a message if the verbosity level is high enough
# Returns   : n/a
# Arguments : message : message string
#             level   : options verbosity level
# Throws    : n/a
# Comments  : n/a
# See also  : n/a
sub verbose {

    # arguments
    my $message = shift;
    my $level   = shift;

    if ( !defined $message ) {
        $plugin->nagios_exit( UNKNOWN,
            q{Internal error: not enough parameters for 'verbose'} );
    }

    if ( !defined $level ) {
        $level = 0;
    }

    if ( $level < $verbosity ) {
        print $message;
    }

    return;

}


##############################################################################
# main
#

################
# Initialization

$critical   = 0;
$help       = q{};
$interface  = q{};
$plugin     = Nagios::Plugin->new( shortname => 'TCPTRAFFIC' );
$reset      = q{};
$speed      = q{};
$status     = 0;
$status_msg = q{};
$verbosity  = 0;
$warning    = 0;

########################
# Command line arguments

Getopt::Long::Configure( 'bundling', 'no_ignore_case' );

$result = GetOptions(
    'critical|c=i'  => \$critical,
    'interface|i=s' => \$interface,
    'help'          => \$help,
    'reset|r'       => \$reset,
    'speed|s=i'     => \$speed,
    'warning|w=i'   => \$warning,
    'verbose|v+'    => \$verbosity,
    'version|V'     => sub { print "check_tcptraffic version $VERSION\n"; exit 3; }
);

if ( !$result || $help) {
    usage(
        -exitval => UNKNOWN,
    );
}

if ( $critical <= 0 ) {
    usage(
        -exitval => UNKNOWN,
        -message => 'Could not parse "critical"',
    );
}

if ( !$interface ) {
    usage(
        -exitval => UNKNOWN,
        -message => 'Could not parse "interface"',
    );
}

if ( !$speed ) {
    usage(
        -exitval => UNKNOWN,
        -message => 'Could not parse "speed"',
    );
}

if ( $warning <= 0 ) {
    usage(
        -exitval => UNKNOWN,
        -message => 'Could not parse "warning"',
   );
}

if ( $critical < $warning ) {
    usage(
        -exitval => UNKNOWN,
        -message => '"critical" has to be greater than "warning"',
    );
}

# check the speed
my $max_check_time = int ( 32_768 / $speed ) ;    # in seconds

$threshold = Nagios::Plugin::Threshold->set_thresholds(
    warning  => $warning,
    critical => $critical,
);

$tmp = "/tmp/check_tcptraffic_status-$interface" . whoami();

########################
# Check the proc entry

my %data = read_proc($interface);

if ( $data{diff} > $max_check_time ) {

    verbose 'the time from last check ('
        . $data{diff}
        . 's) is greater than the maximum check time allowed with speed '
        . $speed
        . ' ('
        . $max_check_time
        . "s):\nsleeping 1s to gather data again\n";

    # time difference is > max_check_time
    # since the counter could overflow
    # we reeinitilize the timer and
    # we perform a 1s check

    write_timer( $data{bytes_in}, $data{bytes_out} );

    sleep 1;

    %data = read_proc($interface);

}

if ( $data{diff} == 0 ) {

    # round up
    $data{diff} = 1;
    
}

my $traffic_in  = abs( int( ( $data{bytes_in} - $data{in} ) / $data{diff} ) );
my $traffic_out = abs( int( ( $data{bytes_out} - $data{out} ) / $data{diff} ) );
my $traffic = $traffic_in + $traffic_out;

$plugin->add_perfdata(
    label     => 'TOTAL',
    value     => sprintf( '%.0f', $traffic ),
    uom       => q{},
    threshold => $threshold,
);

$plugin->add_perfdata(
    label     => 'IN',
    value     => sprintf( '%.0f', $traffic_in ),
    uom       => q{},
);

$plugin->add_perfdata(
    label     => 'OUT',
    value     => sprintf( '%.0f', $traffic_out ),
    uom       => q{},
);

$plugin->add_perfdata(
    label     => 'TIME',
    value     => sprintf( '%.0f', $data{diff}  ),
    uom       => q{},
);

$plugin->nagios_exit(
    $threshold->get_status($traffic),
    "$interface " . sprintf( '%.0f', $traffic ) . " bytes/s"
);

1;
